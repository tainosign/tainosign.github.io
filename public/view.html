<!DOCTYPE html>
<html lang="ja">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>場内人数推移ビュー (Firebase Hosting)</title>
    <!-- Chart.js and Tailwind CSS -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
import {
  getDocs,
  query,
  where,
  orderBy
} from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // ----------------------------------------------------
        // 1. Firebase設定とグローバル変数
        // ----------------------------------------------------
        
        let firebaseConfig = null;
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (e) {
                console.error("Failed to parse __firebase_config:", e);
            }
        }

        if (!firebaseConfig) {
            console.warn("環境変数__firebase_configが見つかりません。フォールバック設定を使用します。");
            firebaseConfig = {
                apiKey: "AIzaSyAgLH9FWBCJy-X11vu0r3YS-VZC-B9M2xA",
                authDomain: "setapanmarketcounter.firebaseapp.com",
                databaseURL: "https://setapanmarketcounter-default-rtdb.firebaseio.com",
                projectId: "setapanmarketcounter",
                storageBucket: "setapanmarketcounter.firebasestorage.app",
                messagingSenderId: "546423839721",
                appId: "1:546423839721:web:70d5c12129fe6cc1594978",
                measurementId: "G-70KHJ0P1P1"
            };
        }

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'setapanmarketcounter'; 
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth;
        let userId = null;
        let daySettings = { day1: null, day2: null }; 
        // ログデータを保持する変数 (リアルタイム処理のために必要)
        let logData = []; 
        let calculationInterval = null; // リアルタイム計算用インターバル

        // UI要素
        const currentCountValueEl = document.getElementById('current-count-value');
        const waitTimeValueEl = document.getElementById('wait-time-value');
        const day1VisitorsEl = document.getElementById('day1-visitors');
        const day2VisitorsEl = document.getElementById('day2-visitors');
        const totalVisitorsEl = document.getElementById('total-visitors');
        const eventDay1DateEl = document.getElementById('event-day1-date');
        const eventDay2DateEl = document.getElementById('event-day2-date');

        const LOG_COLLECTION_PATH = `/artifacts/${appId}/public/data/log`;
        // データベースパス定義ヘルパー
        //const LOG_COLLECTION_PATH = (collectionName) => 
            // パス形式: /artifacts/setapanmarketcounter/public/data/{collectionName}
           // `artifacts/${appId}/public/data/${collectionName}`;

        //const getDayDocRef = (dbInstance) => 
       //     doc(dbInstance, LOG_COLLECTION_PATH('static'), 'day'); // static/day ドキュメントを参照

        //const getLogCollectionRef = (dbInstance) => 
           // collection(dbInstance, LOG_COLLECTION_PATH('log')); // log コレクションを参照
                const getPublicCollectionPath = (collectionName) => 
            // パス形式: /artifacts/setapanmarketcounter/public/data/{collectionName}
            `/artifacts/${appId}/public/data/${collectionName}`;

        const getDayDocRef = (dbInstance) => 
            doc(dbInstance, getPublicCollectionPath('static'), 'day'); // static/day ドキュメントを参照

        const getLogCollectionRef = (dbInstance) => 
            collection(dbInstance, getPublicCollectionPath('log')); // log コレクションを参照
        let isAuthReady = false;

        // Firestoreのコレクションパス (Public Dataとして格納することを想定)
        // 🚨 注意: 実際のデータスキーマに合わせて 'logs' の部分は調整してください。
        // const LOG_COLLECTION_PATH = `artifacts/${appId}/public/data/log`; 

        let isInitialized = false;

        // Firebaseの初期化と認証
        async function initializeFirebase() {
            if (isInitialized) return;
            isInitialized = true;
            
            try {
                // Firebase初期化
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // 認証
                await new Promise((resolve, reject) => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        unsubscribe();
                        if (user) {
                            console.log("Firebase: 既存ユーザーで認証済み");
                            userId = user.uid;
                        } else if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                                console.log("Firebase: カスタムトークンで認証成功");
                            } catch (e) {
                                console.error("Firebase: カスタムトークン認証失敗", e);
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                                console.log("Firebase: 匿名認証にフォールバック");
                            }
                        } else {
                            await signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                            console.log("Firebase: 匿名認証成功");
                        }
                        isAuthReady = true;
                        resolve();
                    }, reject);
                });

                // 認証後にビューの初期化を開始
                window.externalAPI.db = db; // グローバルスコープに公開
                window.externalAPI.userId = userId;
                window.externalAPI.LOG_COLLECTION_PATH = LOG_COLLECTION_PATH;
                window.externalAPI.initializeViewAfterAuth(); 

            } catch (e) {
                console.error("Firebase初期化または認証エラー:", e);
                window.externalAPI.onFailure({ message: `初期化エラー: ${e.message}` });
            }
        }

        // --- 2. GAS関数を置き換えるFirestoreデータ取得ロジック ---

        /**
         * Firestoreから記録された日付のリストを取得する（全件スキャンでユニーク化が必要なため非効率だが、GASロジックを再現）
         * @returns {Promise<string[]>} YYYY-MM-DD形式の日付の配列
         */

async function fetchRecordedDates() {
    console.log("Firestore: 記録された日付リストを取得中...");

    const dates = new Set();
    try {
        // ✅ log コレクションを直接参照
        const logRef = collection(db, getPublicCollectionPath("log"));
        const q = query(logRef, orderBy("timestamp", "desc")); // ✅ timestamp を使用

        const querySnapshot = await getDocs(q);

        querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.timestamp) {
                // ✅ timestamp → JS Date に変換して日付文字列にする
                const ts = data.timestamp.toDate ? data.timestamp.toDate() : new Date(data.timestamp);
                const dateStr = ts.toLocaleDateString("ja-JP", { timeZone: "Asia/Tokyo" });
                dates.add(dateStr);
            }
        });

        const uniqueDates = Array.from(dates).sort().reverse();
        console.log(`Firestore: 記録された日付 ${uniqueDates.length} 件`);
        return uniqueDates;

    } catch (e) {
        console.error("Firestore: 日付リストの取得に失敗しました", e);
        throw new Error("日付リストの取得に失敗しました: " + e.message);
    }
}
        
        /**
         * 特定の日付の全ログを取得し、場内人数と報告件数を計算する
         * @param {string} date YYYY-MM-DD形式の日付
         * @returns {Promise<Array<Array<any>>>} グラフ描画用のデータ配列
         */
        async function fetchDailyCountTimeline(date) {
            console.log(`Firestore: 日付 **${date}** のタイムラインデータを取得中...`);
            let currentCount = 0;
            const chartData = [['日時', '場内人数', '報告件数', '報告内容']];
            
            try {
                // dateフィールドが一致するドキュメントをtimestamp順に取得
                const q = query(
                    collection(db, LOG_COLLECTION_PATH),
                    where("date", "==", date),
                    orderBy("timestamp", "asc")
                );

                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    console.log(`Firestore: **${date}** のログデータは見つかりませんでした。`);
                    return chartData;
                }

                querySnapshot.forEach((doc) => {
                    const row = doc.data();
                    
                    // Firestore TimestampをJavaScript Dateオブジェクトに変換
                    const timestampDate = row.timestamp ? row.timestamp.toDate() : new Date();
                    
                    // タイムスタンプを 'YYYY/MM/DD HH:mm:ss' 形式の文字列に変換
                    const formattedTimestamp = timestampDate.toLocaleDateString('ja-JP', {
                        year: 'numeric', month: '2-digit', day: '2-digit', 
                        hour: '2-digit', minute: '2-digit', second: '2-digit', 
                        hour12: false
                    }).replace(/\//g, '/').replace(/ /g, ' ').replace(',', '');
                    
                    // --- 入退場計算 ---
                    const entryCount = row.entry || 0;
                    const exitCount = row.exit || 0;
                    currentCount += (entryCount - exitCount);
                    currentCount = Math.max(0, currentCount); // 人数は0未満にならない

                    const isCounted = (entryCount > 0 || exitCount > 0);
                    
                    // --- 報告内容集約 ---
                    const vendorDetails = row.vendorDetails || '';
                    const visitorDetails = row.visitorDetails || '';
                    const otherDetails = row.otherDetails || '';
                    
                    let complaintDetails = '';
                    if (vendorDetails) complaintDetails += `[出店者] ${vendorDetails}\n`;
                    if (visitorDetails) complaintDetails += `[来場者] ${visitorDetails}\n`;
                    if (otherDetails) complaintDetails += `[その他] ${otherDetails}\n`;
                    
                    complaintDetails = complaintDetails.trim() || null; 
async function fetchDailyCountTimeline(date) {
    console.log(`Firestore: 日付 **${date}** のタイムラインデータを取得中...`);
    let currentCount = 0;
    const chartData = [['日時', '場内人数', '報告件数', '報告内容']];
    
    try {
        // 🔹 指定日の00:00〜23:59までを日本時間で取得
        const start = new Date(`${date}T00:00:00+09:00`);
        const end = new Date(`${date}T23:59:59+09:00`);

        const q = query(
            collection(db, LOG_COLLECTION_PATH),
            where("timestamp", ">=", start),
            where("timestamp", "<=", end),
            orderBy("timestamp", "asc")
        );

        const querySnapshot = await getDocs(q);

        if (querySnapshot.empty) {
            console.log(`Firestore: **${date}** のログデータは見つかりませんでした。`);
            return chartData;
        }

        querySnapshot.forEach((doc) => {
            const row = doc.data();
            const timestampDate = row.timestamp?.toDate ? row.timestamp.toDate() : new Date(row.timestamp);

            const formattedTimestamp = timestampDate.toLocaleString('ja-JP', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const entryCount = row.type === "in" ? (row.count || 0) : 0;
            const exitCount = row.type === "out" ? (row.count || 0) : 0;
            currentCount += entryCount - exitCount;
            currentCount = Math.max(0, currentCount);

            // 報告内容
            const vendorDetails = row.vendorDetails || '';
            const visitorDetails = row.visitorDetails || '';
            const otherDetails = row.otherDetails || '';
            let complaintDetails = '';
            if (vendorDetails) complaintDetails += `[出店者] ${vendorDetails}\n`;
            if (visitorDetails) complaintDetails += `[来場者] ${visitorDetails}\n`;
            if (otherDetails) complaintDetails += `[その他] ${otherDetails}\n`;
            complaintDetails = complaintDetails.trim() || null;
            const complaintCount = complaintDetails ? 1 : 0;

            // グラフ用データ追加
            chartData.push([
                formattedTimestamp,
                currentCount,
                complaintCount,
                complaintDetails
            ]);
        });

        console.log(`Firestore: 抽出されたデータ行数 (ヘッダー含む): ${chartData.length}`);
        return chartData;

    } catch (e) {
        console.error("Firestore: タイムラインデータの取得に失敗しました", e);
        throw new Error("タイムラインデータの取得に失敗しました: " + e.message);
    }
                }
        
        // --- 3. グローバルなAPIをエクスポートして、HTML側のスクリプトから呼び出せるようにする ---
        window.externalAPI = {
            initializeFirebase,
            fetchRecordedDates,
            fetchDailyCountTimeline,
            db: null,
            userId: null,
            LOG_COLLECTION_PATH: null,
            // 認証完了後にHTML側から呼ばれる関数 (HTML側で定義)
            initializeViewAfterAuth: () => { /* プレースホルダー */ },
            onFailure: () => { /* プレースホルダー */ }
        };
        
        // ページロード時にFirebaseの初期化を開始
        window.onload = initializeFirebase;
    </script>

<style>
    /* Tailwind CSSの有効化 */
    @layer utilities {
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: #6c757d;
            height: 100%;
            text-align: center;
        }
    }
</style>
<script>
    // Tailwind CSSの設定
    tailwind.config = {
        theme: {
            extend: {
                fontFamily: {
                    sans: ['Inter', 'sans-serif'],
                },
            },
        },
    }
</script>

</head>
<body class="bg-gray-100 font-sans p-0 m-0 min-h-screen">
    <!-- モーダル（カスタムアラート） -->
    <div id="modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center z-50 transition-opacity duration-300 opacity-0">
        <div class="bg-white rounded-xl shadow-2xl p-6 m-4 max-w-lg w-full transform transition-transform duration-300 scale-95">
            <h3 class="text-xl font-bold mb-4 text-red-600 border-b pb-2">記録詳細</h3>
            <pre id="modal-content" class="text-gray-700 whitespace-pre-wrap text-sm leading-relaxed"></pre>
            <div class="flex justify-end mt-6">
                <button onclick="closeModal()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">閉じる</button>
            </div>
        </div>
    </div>
    
    <div class="container mx-auto max-w-screen-2xl px-4 py-6">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-blue-600 mb-2">場内人数推移ビュー</h1>
            <p class="text-gray-500">Firestore ログデータに基づきリアルタイムに更新されます</p>
        </header>

        <!-- グラフコンテナ -->
        <div id="chart-container" class="w-full h-[75vh] min-h-[400px] bg-white rounded-xl shadow-lg mb-6 p-4">
            <canvas id="chart_div" class="loading">
                <p>Firebase認証とデータを取得中...</p>
            </canvas>
        </div>

        <!-- 表示単位コントロール -->
        <div class="bg-white rounded-xl shadow-md p-4 mb-6">
            <label class="block text-lg font-semibold text-gray-700 mb-3">表示単位:</label>
            <div class="flex flex-wrap justify-between gap-2 unit-buttons-wrapper"> 
                <button class="unit-btn flex-1 min-w-0 px-3 py-2 text-sm md:text-base border border-blue-500 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition active" data-unit="second">1秒</button>
                <button class="unit-btn flex-1 min-w-0 px-3 py-2 text-sm md:text-base border border-blue-500 rounded-lg text-blue-500 hover:bg-blue-50 transition" data-unit="minute">1分</button>
                <button class="unit-btn flex-1 min-w-0 px-3 py-2 text-sm md:text-base border border-blue-500 rounded-lg text-blue-500 hover:bg-blue-50 transition" data-unit="ten-minutes">10分</button>
                <button class="unit-btn flex-1 min-w-0 px-3 py-2 text-sm md:text-base border border-blue-500 rounded-lg text-blue-500 hover:bg-blue-50 transition" data-unit="thirty-minutes">30分</button>
                <button class="unit-btn flex-1 min-w-0 px-3 py-2 text-sm md:text-base border border-blue-500 rounded-lg text-blue-500 hover:bg-blue-50 transition" data-unit="hour">1時間</button>
            </div>
        </div>

        <!-- 日付選択とステータス表示 -->
        <div class="bg-white rounded-xl shadow-md p-4 mb-6 controls">
            <label for="dateSelector" class="block text-lg font-semibold text-gray-700 mb-3">表示する日付を選択:</label>
            <select id="dateSelector" class="p-3 border border-gray-300 rounded-lg w-full text-lg focus:ring-blue-500 focus:border-blue-500">
                <!-- オプションはJSで追加されます -->
            </select>
            <div id="status" class="mt-4 text-gray-500 text-sm text-right"></div>
        </div>

        <!-- メニューへ戻るボタン (静的ページなのでリンクはなし) -->
        <div class="text-center mb-8">
            <button onclick="window.history.back()" class="w-full md:w-96 bg-gray-500 text-white px-6 py-3 text-lg rounded-lg hover:bg-gray-600 transition duration-150 shadow-lg">前の画面へ戻る</button>
        </div>

    </div>

<script>
    document.addEventListener("DOMContentLoaded", () => {
  if (window.externalAPI) {
    window.externalAPI.initializeViewAfterAuth = initializeView;
    window.externalAPI.onFailure = onFailure;
  } else {
    const checkAPI = setInterval(() => {
      if (window.externalAPI) {
        window.externalAPI.initializeViewAfterAuth = initializeView;
        window.externalAPI.onFailure = onFailure;
        clearInterval(checkAPI);
      }
    }, 100);
  }
});
    // --- 4. クライアントサイドのコアロジック ---
    const dateSelector = document.getElementById('dateSelector');
    const statusDiv = document.getElementById('status');
    let myChart = null; 
    let rawChartData = null; 
    let currentUnit = 'second'; 
    const refreshInterval = 60000; // 60秒ごとに更新
    let autoRefreshTimer = null;
    
    // --- モーダル関数 (alert()の代わり) ---
    function openModal(title, content) {
        document.getElementById('modal-content').textContent = content;
        document.querySelector('#modal h3').textContent = title;
        const modal = document.getElementById('modal');
        modal.classList.remove('hidden', 'opacity-0');
        modal.classList.add('flex');
        setTimeout(() => {
            modal.classList.remove('opacity-0');
            document.querySelector('#modal > div').classList.remove('scale-95');
        }, 10);
    }

    function closeModal() {
        const modal = document.getElementById('modal');
        document.querySelector('#modal > div').classList.add('scale-95');
        modal.classList.add('opacity-0');
        setTimeout(() => {
            modal.classList.add('hidden');
        }, 300);
    }
    
    // --- イベントリスナー設定 ---
    document.addEventListener('DOMContentLoaded', () => {
        // 単位変更ボタンのイベントリスナー
        document.querySelectorAll('.unit-btn').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.unit-btn').forEach(btn => {
                    btn.classList.remove('bg-blue-500', 'text-white');
                    btn.classList.add('text-blue-500', 'hover:bg-blue-50');
                });
                this.classList.add('bg-blue-500', 'text-white');
                this.classList.remove('text-blue-500', 'hover:bg-blue-50');

                currentUnit = this.getAttribute('data-unit');
                if (rawChartData) {
                    processAndDrawChart(rawChartData);
                }
            });
        });
        
        // 日付選択変更のイベントリスナー (populateDateSelector内でセットアップ)
    });
    
    // // --- Firebase認証完了後に実行される初期化関数 (import scriptからコールされる) ---
  //  window.externalAPI.initializeViewAfterAuth = initializeView;
   // window.externalAPI.onFailure = onFailure;


    function setupAutoRefresh() {
        if (autoRefreshTimer) {
            clearInterval(autoRefreshTimer);
        }
        // 初回データ取得後、60秒ごとに drawChart を再実行
        autoRefreshTimer = setInterval(() => {
            const currentDate = dateSelector.value;
            console.log(`[AutoRefresh] ${currentDate} のデータを再取得中...`);
            drawChart(currentDate); 
        }, refreshInterval);
    }

    async function initializeView() {
        try {
            // Firebaseから日付リストを取得
            const dates = await window.externalAPI.fetchRecordedDates();
            populateDateSelector(dates);
        } catch (error) {
            onFailure(error);
        }
    }

    function populateDateSelector(dates) {
        if (!Array.isArray(dates) || dates.length === 0) {
            document.getElementById('chart_div').textContent = `カウントの記録がありません。`;
            document.querySelector('.controls').classList.add('hidden');
            document.querySelector('.unit-buttons-wrapper').parentNode.classList.add('hidden');
            return;
        }
        
        // 日付オプションの生成
        dateSelector.innerHTML = '';
        dates.forEach(date => {
            const option = document.createElement('option');
            option.value = date;
            option.textContent = date;
            dateSelector.appendChild(option);
        });

        // URLパラメータがあれば初期選択、なければ最新の日付を選択
        const urlParams = new URLSearchParams(window.location.search);
        const initialDate = urlParams.get('date') || dates[0];
        dateSelector.value = initialDate;
        
        // 日付選択変更イベントの設定
        dateSelector.addEventListener('change', function() {
            drawChart(dateSelector.value);
        });

        // 初回描画と自動更新の設定
        drawChart(initialDate);
        setupAutoRefresh();
    }

    async function drawChart(date) {
        if (myChart) {
            myChart.destroy();
        }

        const container = document.getElementById('chart-container');
        // canvas要素を再生成し、ロード中メッセージを表示
        container.innerHTML = `<canvas id="chart_div" class="loading"><p>データを取得中...</p></canvas>`;

        try {
            // Firebaseからタイムラインデータを取得
            const chartData = await window.externalAPI.fetchDailyCountTimeline(date);
            onDataReceived(chartData);

        } catch (error) {
            onFailure(error);
        }
    }

    function onDataReceived(chartData) {
        rawChartData = chartData; 

        const container = document.getElementById('chart-container');

        if (!rawChartData || rawChartData.length <= 1) { 
            container.innerHTML = `<canvas id="chart_div" class="loading"><p class="text-xl font-medium text-gray-600">**${dateSelector.value}** には入退場の記録がありません。</p></canvas>`;
            return;
        }

        processAndDrawChart(rawChartData);
    }

    function processAndDrawChart(data) {
        const aggregated = aggregateData(data, currentUnit);

        const chartLabels = aggregated.labels;
        const attendanceData = aggregated.attendance;
        const complaintData = aggregated.complaint;
        const complaintMap = aggregated.complaintMap;

        const chartElement = document.getElementById('chart_div');
        if (!chartElement) {
            console.error(`[DOM ERROR] ID 'chart_div' の canvas 要素が見つかりません。`);
            return;
        }
        const ctx = chartElement.getContext('2d');

        if (myChart) {
            myChart.destroy();
        }
        
        try {
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [
                        {
                            label: '場内人数',
                            data: attendanceData,
                            yAxisID: 'y1',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.2,
                            fill: false,
                            pointRadius: (currentUnit === 'second' || currentUnit === 'minute') ? 3 : 0 
                        },
                        {
                            label: 'トラブル等記録件数',
                            data: complaintData,
                            yAxisID: 'y2',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.8)',
                            type: 'bar',
                            order: 1,
                            pointRadius: 0,
                            barPercentage: 0.8 
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 500 }, 
                    onClick: (e) => {
                        const activePoints = myChart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
                        if (activePoints.length > 0) {
                            const firstPoint = activePoints[0];
                            const label = chartLabels[firstPoint.index];
                            
                            if (complaintMap[label]) {
                                openModal(`【トラブル等記録内容 - ${dateSelector.value} ${label}】`, complaintMap[label]);
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${dateSelector.value} の場内/トラブル等記録推移 (${getUnitLabel(currentUnit)}単位)`,
                            font: { size: 18 } 
                        },
                        legend: { 
                            position: 'bottom',
                            labels: { font: { size: 14 } } 
                        },
                        tooltip: {
                            bodyFont: { size: 14 }, 
                            titleFont: { size: 14 }
                        }
                    },
                    scales: {
                        y1: { 
                            type: 'linear', position: 'left',
                            title: { display: true, text: '場内人数', font: { size: 18 } }, 
                            beginAtZero: true,
                            ticks: { font: { size: 14 } } 
                        },
                        y2: { 
                            type: 'linear', position: 'right',
                            title: { display: true, text: 'トラブル等件数 (集計)', font: { size: 18 } }, 
                            min: 0,
                            max: Math.ceil(Math.max(1, ...complaintData) * 1.1), 
                            grid: { drawOnChartArea: false },
                            ticks: { font: { size: 14, stepSize: 1 } } 
                        },
                        x: {
                            title: { display: true, text: '時刻', font: { size: 18 } },
                            ticks: {
                                autoSkip: true,
                                maxRotation: 0, 
                                minRotation: 0,
                                font: { size: 14 }, 
                                callback: function(val, index) {
                                    const fullTime = this.getLabelForValue(val);
                                    // 秒・分単位では5分ごとにラベルを表示するロジックを再現
                                    if (currentUnit === 'second' || currentUnit === 'minute') {
                                        const parts = fullTime.split(':'); 
                                        const minutes = parseInt(parts[1]);
                                        if (minutes % 5 !== 0) return '';
                                    }
                                    return formatTimeLabel(fullTime, currentUnit);
                                }
                            }
                        }
                    }
                }
            });
        } catch (e) {
            console.error(`[CHART ERROR] Chart.js の描画中に致命的なエラーが発生しました:`, e); 
        }

        statusDiv.textContent = `最終更新: ${new Date().toLocaleTimeString('ja-JP', {hour12: false})}`;
    }

    function aggregateData(data, unit) {
        if (unit === 'second') {
            const labels = [];
            const attendance = [];
            const complaint = [];
            const complaintMap = {};
            
            for (let i = 1; i < data.length; i++) {
                const row = data[i];
                const timePart = row[0]; // HH:mm:ss
                
                labels.push(timePart);
                attendance.push(row[1]);
                complaint.push(row[2]);
                
                if (row[2] > 0 && row[3]) {
                    // complaintMapにはHH:mm:ssと詳細を格納
                    complaintMap[timePart] = `${timePart} ${row[3]}`; 
                }
            }
            return { labels, attendance, complaint, complaintMap };
        }

        const intervalMinutes = {
            'minute': 1,
            'ten-minutes': 10,
            'thirty-minutes': 30,
            'hour': 60
        }[unit];
        
        const aggregated = {}; 

        for (let i = 1; i < data.length; i++) {
            const row = data[i];
            const timestampString = row[0]; // HH:mm:ss
            
            // 日付情報がないため、今日のダミー日付を使ってDateオブジェクトを作成
            const today = new Date().toISOString().substring(0, 10); // YYYY-MM-DD
            const timestamp = new Date(`${today} ${timestampString}`);
            
            if (isNaN(timestamp.getTime())) {
                continue;
            }
            
            const attendanceCount = row[1];
            const complaintCount = row[2];
            const complaintDetails = row[3];
            
            let hour = timestamp.getHours();
            let minute = timestamp.getMinutes();
            
            // 単位に基づいた分への切り捨て
            minute = Math.floor(minute / intervalMinutes) * intervalMinutes;

            const minuteStr = String(minute).padStart(2, '0');
            const hourStr = String(hour).padStart(2, '0');
            const key = `${hourStr}:${minuteStr}`; // 集計キー HH:mm
            
            if (!aggregated[key]) {
                aggregated[key] = {
                    lastAttendance: attendanceCount, 
                    complaintSum: 0,
                    complaintDetails: [] 
                };
            } else {
                // 最後のログの場内人数を採用
                aggregated[key].lastAttendance = attendanceCount; 
            }

            aggregated[key].complaintSum += complaintCount;
            
            if (complaintDetails) {
                // 時刻情報 (HH:mm:ss) と内容をセットにしたオブジェクトを配列にプッシュ
                aggregated[key].complaintDetails.push({
                    time: timestampString, // HH:mm:ss
                    detail: complaintDetails
                });
            }
        }

        const labels = [];
        const attendance = [];
        const complaint = [];
        const complaintMap = {};

        // 集計キーでソートして最終データを作成
        Object.keys(aggregated).sort().forEach(key => {
            const item = aggregated[key];
            labels.push(key);
            attendance.push(item.lastAttendance);
            complaint.push(item.complaintSum);
            
            if (item.complaintDetails.length > 0) {
                // 集計単位の時刻 (HH:mm) に紐づく全てのトラブル詳細を結合
                complaintMap[key] = item.complaintDetails.map(record => {
                    return `(${record.time}) ${record.detail}`; 
                }).join('\n----------\n'); 
            }
        });
        
        return { labels, attendance, complaint, complaintMap };
    }

    function getUnitLabel(unit) {
        return {
            'second': '1秒',
            'minute': '1分',
            'ten-minutes': '10分',
            'thirty-minutes': '30分',
            'hour': '1時間'
        }[unit];
    }

    function formatTimeLabel(timeString, unit) {
        // timeStringは 'HH:mm:ss' または 'HH:mm' の形式を想定
        const parts = timeString.split(':');

        const h = parts[0]; // 時
        const m = parts[1]; // 分
        const s = parts[2]; // 秒 

        if (unit === 'second') {
            // 1秒単位: 時\n分\n秒
            return [h, m, s];
        } else if (unit === 'minute') {
            // 1分単位: 時\n分
            return [h, m];
        } else {
            // 10分、30分、1時間単位: 時のみ、または時:分
            return (parts.length > 1 && m !== '00') ? [h, m] : [h];
        }
    }
    
    function onFailure(error) {
        if (autoRefreshTimer) {
            clearInterval(autoRefreshTimer);
        }
        statusDiv.textContent = `エラー: データの取得に失敗しました。`;
        console.error(`[FATAL ERROR] データ取得またはFirebase処理失敗:`, error);
        if (myChart) myChart.destroy();
        const container = document.getElementById('chart-container');
        container.innerHTML = `<canvas id="chart_div" class="loading"><p class="text-xl font-medium text-red-500">グラフの読み込みに失敗しました。</p><p class="text-sm text-gray-500 mt-2">${error.message || '不明なエラー'}</p></canvas>`;
    }
</script>
</body>
</html>
