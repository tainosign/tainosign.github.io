<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>場内人数・イベントログ推移リアルタイムビュー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        /* カスタムスタイル */
        .font-['Inter'] { font-family: 'Inter', sans-serif; }
        #chartContainer {
            position: relative;
            height: 100%;
            min-height: 400px;
        }
        /* モーダル表示のためのスクロール禁止 */
        .modal-open { overflow: hidden; }
        /* グラフのキャンバス */
        #chart_div { width: 100%; height: 100%; }
        /* Chart.jsのX軸ラベルの改行対応 */
        .chartjs-render-monitor { white-space: pre-wrap; }
    </style>
</head>
<body class="bg-gray-50 font-['Inter']">

    <!-- メインアプリケーションコンテナ -->
    <div id="app" class="min-h-screen p-4 sm:p-6 lg:p-8">
        <!-- コンテンツはJSで動的にロードされます -->
    </div>

    <!-- トラブル詳細モーダル -->
    <div id="modalContainer" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-gray-900 bg-opacity-75 p-4 transition-opacity duration-300 opacity-0" aria-modal="true" role="dialog">
        <div id="modalContent" class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden transform transition-transform duration-300 scale-95">
            <div id="modalHeader" class="p-4 border-b border-gray-200 flex justify-between items-center bg-red-500 text-white">
                <h3 id="modalTitle" class="text-lg font-bold"></h3>
                <button onclick="closeModal()" class="text-white hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <div id="modalDetails" class="p-6 max-h-[70vh] overflow-y-auto whitespace-pre-wrap text-gray-700 text-sm">
                <!-- 詳細内容 -->
            </div>
            <div class="p-4 border-t border-gray-200 text-right">
                <button
                    onclick="closeModal()"
                    class="px-6 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150"
                >
                    閉じる
                </button>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase SDKのインポート
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =========================================================================
        // グローバル変数と初期設定
        // =========================================================================

        const firebaseConfig = typeof __firebase_config !== 'undefined' && __firebase_config.length > 0 ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // 状態管理変数 (React Stateの代替)
        let db = null;
        let auth = null;
        let userId = null;
        let rawLogData = [];
        let datesList = [];
        let timelineData = [];
        let selectedDate = 'day2'; // 初期値は暫定的に 'day2' に設定
        let aggregationUnit = 'second';
        let isLoading = true;
        let error = null;
        let modalContent = null;
        
        let chartInstance = null;
        let logUnsubscribe = null;

        // =========================================================================
        // データ集計ロジック (Reactコードから移植)
        // =========================================================================

        /**
         * 単位名から表示ラベルを取得
         */
        const getUnitLabel = (unit) => {
            return {
                'second': '1秒', 'minute': '1分', 'ten-minutes': '10分',
                'thirty-minutes': '30分', 'hour': '1時間'
            }[unit];
        };

        /**
         * 時刻ラベルの表示をフォーマット
         */
        const formatTimeLabel = (timeString, unit) => {
            const parts = timeString.split(':');
            const h = parts[0]; 
            const m = parts[1]; 
            const s = parts[2]; 

            if (unit === 'second') {
                // 1秒単位: 時\n分\n秒
                return [h, m, s].join('\n'); 
            } else if (unit === 'minute') {
                // 1分単位: 時\n分
                return [h, m].join('\n');
            } else {
                // 10分、30分、1時間単位: 時のみ、または時:分
                return (parts.length > 1 && m !== '00') ? [h, m].join(':') : h;
            }
        };

        /**
         * データを指定された単位で集計
         */
        const aggregateData = (data, unit) => {
            if (unit === 'second') {
                const labels = [];
                const attendance = [];
                const complaint = [];
                const complaintMap = {};

                data.forEach(row => {
                    const timePart = row.timestamp.split(' ')[1]; // HH:mm:ss

                    labels.push(timePart);
                    attendance.push(row.currentCount);
                    complaint.push(row.complaintCount);

                    if (row.complaintCount > 0 && row.complaintDetails) {
                        complaintMap[timePart] = row.complaintDetails.replace(/\n/g, ' / ');
                    }
                });

                return { labels, attendance, complaint, complaintMap };
            }

            const intervalMinutes = {
                'minute': 1,
                'ten-minutes': 10,
                'thirty-minutes': 30,
                'hour': 60
            }[unit];

            const aggregated = {};

            data.forEach(row => {
                const timestampString = row.timestamp;
                const timestamp = new Date(timestampString.replace(/\//g, '-'));

                if (isNaN(timestamp.getTime())) {
                    console.error(`[AGGREGATE-TIME ERROR] 日時文字列の解析に失敗しました: ${timestampString}`);
                    return;
                }

                const attendanceCount = row.currentCount;
                const complaintCount = row.complaintCount;
                const complaintDetails = row.complaintDetails;

                let hour = timestamp.getHours();
                let minute = timestamp.getMinutes();

                minute = Math.floor(minute / intervalMinutes) * intervalMinutes;

                const minuteStr = String(minute).padStart(2, '0');
                const hourStr = String(hour).padStart(2, '0');
                const key = `${hourStr}:${minuteStr}`; // HH:MM (集計キー)

                const fullTimeString = timestampString.split(' ')[1]; // HH:mm:ss

                if (!aggregated[key]) {
                    aggregated[key] = {
                        lastAttendance: attendanceCount, 
                        complaintSum: 0,
                        complaintDetails: []
                    };
                } else {
                    aggregated[key].lastAttendance = attendanceCount; 
                }

                aggregated[key].complaintSum += complaintCount;

                if (complaintDetails) {
                    aggregated[key].complaintDetails.push({
                        time: fullTimeString.substring(0, 8), // HH:mm:ss
                        detail: complaintDetails
                    });
                }
            });

            const labels = [];
            const attendance = [];
            const complaint = [];
            const complaintMap = {};

            // 時刻順にソートして配列に格納
            Object.keys(aggregated).sort().forEach(key => {
                const item = aggregated[key];
                labels.push(key);
                attendance.push(item.lastAttendance);
                complaint.push(item.complaintSum);

                if (item.complaintDetails.length > 0) {
                    // complaintMapのキーは集計単位の時刻 (HH:MM)
                    complaintMap[key] = item.complaintDetails.map(record => {
                        return `${record.time} ${record.detail}`;
                    }).join('\n---\n');
                }
            });

            return { labels, attendance, complaint, complaintMap };
        };


        /**
         * 生のログデータからタイムラインデータ（場内人数とトラブル）を計算
         */
        const calculateTimeline = (rawLogs, date) => {
            const filteredLogs = rawLogs.filter(log => log.event_day === date);
            
            // timestamp (Firestore Timestamp) で昇順にソート
            filteredLogs.sort((a, b) => a.timestamp.toDate().getTime() - b.timestamp.toDate().getTime());

            let currentCount = 0; 
            const timeline = [];

            filteredLogs.forEach(log => {
                const logTimestamp = log.timestamp.toDate();
                const formattedTimestamp = `${logTimestamp.getFullYear()}/${String(logTimestamp.getMonth() + 1).padStart(2, '0')}/${String(logTimestamp.getDate()).padStart(2, '0')} ${String(logTimestamp.getHours()).padStart(2, '0')}:${String(logTimestamp.getMinutes()).padStart(2, '0')}:${String(logTimestamp.getSeconds()).padStart(2, '0')}`;
                
                let complaintCount = 0;
                let complaintDetails = null;

                if (log.type === 'in' || log.type === 'out') {
                    const countValue = log.count || 1; 
                    if (log.type === 'in') {
                        currentCount += countValue;
                    } else if (log.type === 'out') {
                        currentCount = Math.max(0, currentCount - countValue); 
                    }
                } else {
                    complaintCount = 1; 
                    complaintDetails = `[${log.type}] ${log.content || log.vendor_name || '詳細不明'}`;
                    if (log.place) {
                        complaintDetails += ` (場所: ${log.place})`;
                    }
                }

                timeline.push({
                    timestamp: formattedTimestamp,
                    currentCount: currentCount,
                    complaintCount: complaintCount,
                    complaintDetails: complaintDetails
                });
            });

            return timeline;
        };


        // =========================================================================
        // Chart.js 描画ロジック
        // =========================================================================

        /**
         * Chart.jsを初期化し、グラフを描画/更新する
         */
        const drawChart = () => {
            const chartCanvas = document.getElementById('chart_div');
            if (!window.Chart || !chartCanvas || timelineData.length === 0) {
                // ログがない場合やChart.jsがロードされていない場合のメッセージ表示
                if (!isLoading) {
                    const context = chartCanvas ? chartCanvas.getContext('2d') : null;
                    if (context) {
                        const message = !window.Chart 
                            ? 'Chart.jsが読み込まれていません。'
                            : `${selectedDate} の記録がありません。`;
                        
                        // キャンバスをクリア
                        context.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                        // サイズがまだ設定されていない場合があるため、親要素のサイズを取得して設定
                        const container = chartCanvas.parentElement;
                        chartCanvas.width = container.clientWidth;
                        chartCanvas.height = container.clientHeight;

                        context.font = "16px Inter, sans-serif";
                        context.textAlign = "center";
                        context.fillStyle = "#6b7280"; // gray-500
                        context.fillText(message, chartCanvas.width / 2, chartCanvas.height / 2);
                    }
                }
                return;
            }

            const { labels, attendance, complaint, complaintMap } = aggregateData(timelineData, aggregationUnit);
            const ctx = chartCanvas.getContext('2d');

            // 既存のチャートがあれば破棄
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            // 最大人数と最大報告件数を計算
            const maxAttendance = Math.max(10, ...attendance);
            const maxComplaint = Math.max(1, ...complaint);

            try {
                chartInstance = new window.Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: '場内人数',
                                data: attendance,
                                yAxisID: 'y1',
                                borderColor: 'rgba(52, 211, 153, 1)', 
                                backgroundColor: 'rgba(52, 211, 153, 0.4)',
                                tension: 0.2,
                                fill: false,
                                pointRadius: (aggregationUnit === 'second' || aggregationUnit === 'minute') ? 3 : 0
                            },
                            {
                                label: 'トラブル等記録件数',
                                data: complaint,
                                yAxisID: 'y2',
                                borderColor: 'rgba(239, 68, 68, 1)', 
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                type: 'bar',
                                order: 1,
                                pointRadius: 0,
                                barPercentage: 0.8
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: { duration: 500 },
                        onClick: (e) => {
                            const chart = chartInstance;
                            if (!chart) return;

                            const activePoints = chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
                            if (activePoints.length > 0) {
                                const firstPoint = activePoints[0];
                                const label = labels[firstPoint.index]; 

                                if (complaintMap[label]) {
                                    showModal({
                                        title: `【トラブル等記録内容 - ${label}】`,
                                        details: complaintMap[label]
                                    });
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${selectedDate} の場内/トラブル等記録推移 (${getUnitLabel(aggregationUnit)}単位)`,
                                font: { size: 18, family: 'Inter, sans-serif' }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { font: { size: 14, family: 'Inter, sans-serif' } }
                            },
                            tooltip: {
                                bodyFont: { size: 14, family: 'Inter, sans-serif' },
                                titleFont: { size: 14, family: 'Inter, sans-serif' }
                            }
                        },
                        scales: {
                            y1: {
                                type: 'linear', position: 'left',
                                title: { display: true, text: '場内人数', font: { size: 18, family: 'Inter, sans-serif' } },
                                beginAtZero: true,
                                max: maxAttendance * 1.1, 
                                ticks: { font: { size: 14, family: 'Inter, sans-serif' } }
                            },
                            y2: {
                                type: 'linear', position: 'right',
                                title: { display: true, text: 'トラブル等件数 (集計)', font: { size: 18, family: 'Inter, sans-serif' } },
                                min: 0,
                                max: maxComplaint * 1.2, 
                                grid: { drawOnChartArea: false },
                                ticks: { stepSize: 1, font: { size: 14, family: 'Inter, sans-serif' } }
                            },
                            x: {
                                title: { display: true, text: '時刻', font: { size: 18, family: 'Inter, sans-serif' } },
                                ticks: {
                                    autoSkip: true,
                                    maxRotation: 0,
                                    minRotation: 0,
                                    font: { size: 14, family: 'Inter, sans-serif' },
                                    callback: function(val) {
                                        // Chart.jsのtick callbackは、描画時に改行文字をサポートします
                                        const fullTime = labels[val]; 
                                        return formatTimeLabel(fullTime, aggregationUnit);
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (e) {
                console.error("[CHART ERROR] Chart.js failed to draw:", e);
                setError("グラフ描画中にエラーが発生しました。");
                renderApp(); // エラーメッセージを表示するためにUIを再レンダリング
            }
        };

        // =========================================================================
        // モーダル処理
        // =========================================================================

        window.showModal = (content) => {
            modalContent = content;
            const container = document.getElementById('modalContainer');
            const titleEl = document.getElementById('modalTitle');
            const detailsEl = document.getElementById('modalDetails');

            titleEl.textContent = content.title;
            detailsEl.textContent = content.details;
            
            // アニメーション用のクラス設定
            container.classList.remove('hidden', 'opacity-0');
            container.classList.add('flex', 'opacity-100');
            document.getElementById('modalContent').classList.remove('scale-95');
            document.getElementById('modalContent').classList.add('scale-100');

            document.body.classList.add('modal-open');
        };

        window.closeModal = () => {
            modalContent = null;
            const container = document.getElementById('modalContainer');
            
            // アニメーション用のクラス設定
            document.getElementById('modalContent').classList.remove('scale-100');
            document.getElementById('modalContent').classList.add('scale-95');

            setTimeout(() => {
                container.classList.remove('flex', 'opacity-100');
                container.classList.add('hidden', 'opacity-0');
                document.body.classList.remove('modal-open');
            }, 300); // 300msのアニメーション後に非表示
        };


        // =========================================================================
        // DOMイベントハンドラ (状態変更と再描画トリガー)
        // =========================================================================

        window.handleDateChange = (event) => {
            const newDate = event.target.value;
            if (newDate !== selectedDate) {
                selectedDate = newDate;
                recalculateAndRender();
            }
        };

        window.handleUnitChange = (unit) => {
            if (unit !== aggregationUnit) {
                aggregationUnit = unit;
                drawChart(); // 単位が変わった場合はチャートのみ再描画
                renderUnitButtons(); // ボタンの状態を更新
            }
        };

        // =========================================================================
        // UIレンダリング関数
        // =========================================================================

        /**
         * アプリケーションのメインUIをレンダリングする
         */
        const renderApp = () => {
            const appDiv = document.getElementById('app');
            let contentHTML = '';

            if (isLoading) {
                contentHTML = `
                    <div class="flex items-center justify-center min-h-screen bg-gray-50">
                        <div class="text-center p-8 bg-white rounded-xl shadow-lg">
                            <svg class="animate-spin h-8 w-8 text-blue-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <p class="text-gray-700 font-semibold">データを準備中... (ログをロードして集計しています)</p>
                        </div>
                    </div>
                `;
            } else if (error) {
                contentHTML = `
                    <div class="flex items-center justify-center min-h-screen bg-red-50">
                        <div class="p-8 bg-white rounded-xl shadow-lg border border-red-400">
                            <h2 class="text-xl font-bold text-red-600 mb-2">エラーが発生しました</h2>
                            <p class="text-gray-700">${error}</p>
                        </div>
                    </div>
                `;
            } else {
                // メインコンテンツ
                contentHTML = `
                    <header class="text-center mb-6">
                        <h1 class="text-3xl sm:text-4xl font-extrabold text-blue-600 tracking-tight">場内人数・イベントログ推移リアルタイムビュー</h1>
                        <p class="text-sm text-gray-500 mt-1">最終更新: ${new Date().toLocaleTimeString('ja-JP', { hour12: false })}</p>
                    </header>

                    <div class="bg-white rounded-xl shadow-xl p-4 sm:p-6 mb-6 h-[70vh] min-h-[400px]">
                        <h2 class="text-lg font-semibold text-gray-800 mb-4">場内人数とトラブル記録の推移</h2>
                        <div id="chartContainer" class="w-full relative">
                            <canvas id="chart_div"></canvas>
                        </div>
                    </div>

                    <div class="max-w-4xl mx-auto">
                        <!-- 日付選択コントロール -->
                        <div class="bg-white p-4 rounded-xl shadow-lg mb-6">
                            <label for="dateSelector" class="block text-lg font-bold text-gray-700 mb-3">表示するイベント日を選択 (event_day):</label>
                            <select
                                id="dateSelector"
                                onchange="handleDateChange(event)"
                                class="w-full p-3 text-lg border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150 shadow-sm"
                            >
                                <!-- オプションはrenderDateSelectorで動的に追加されます -->
                            </select>
                        </div>

                        <!-- 単位選択コントロール -->
                        <div class="bg-white p-4 rounded-xl shadow-lg mb-6">
                            <label class="block text-lg font-bold text-gray-700 mb-3">表示単位:</label>
                            <div id="unitButtonsContainer" class="flex flex-wrap justify-between gap-2 overflow-x-auto p-1">
                                <!-- ボタンはrenderUnitButtonsで動的に追加されます -->
                            </div>
                        </div>

                        <!-- ユーザーID表示（デバッグ・連携用） -->
                        <div class="text-sm text-gray-500 text-center p-3 rounded-lg bg-white shadow-sm mb-6">
                            <p>
                                **現在のユーザーID**: <span class="font-mono text-xs break-all">${userId || '認証中...'}</span>
                            </p>
                        </div>

                        <!-- メニューへ戻るボタン (デモ) -->
                        <div class="text-center">
                            <button
                                onclick="console.log('メニューへ戻るボタンがクリックされました')"
                                class="w-full max-w-lg py-3 bg-gray-500 text-white font-semibold text-lg rounded-xl shadow-lg hover:bg-gray-600 transition duration-200"
                            >
                                メニューへ戻る (デモ)
                            </button>
                        </div>
                    </div>
                `;
            }
            appDiv.innerHTML = contentHTML;

            if (!isLoading && !error) {
                // コントロールとチャートのレンダリングを呼び出す
                renderDateSelector();
                renderUnitButtons();
                // グラフはDOMが完全にロードされた後、またはデータ更新時に描画
                // 初期ロード時に1回実行
                if (window.Chart) {
                    drawChart();
                }
            }
        };

        /**
         * 日付選択ドロップダウンをレンダリングする
         */
        const renderDateSelector = () => {
            const selector = document.getElementById('dateSelector');
            if (!selector) return;

            // オプションをクリア
            selector.innerHTML = ''; 

            if (datesList.length > 0) {
                datesList.forEach(date => {
                    const option = document.createElement('option');
                    option.value = date;
                    option.textContent = date;
                    if (date === selectedDate) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            } else {
                const option = document.createElement('option');
                option.value = selectedDate;
                option.textContent = `${selectedDate} (ログなし)`;
                selector.appendChild(option);
            }
        };

        /**
         * 単位選択ボタンをレンダリングする
         */
        const renderUnitButtons = () => {
            const container = document.getElementById('unitButtonsContainer');
            if (!container) return;

            container.innerHTML = ''; 

            const units = ['second', 'minute', 'ten-minutes', 'thirty-minutes', 'hour'];
            units.forEach(unit => {
                const isActive = aggregationUnit === unit;
                const button = document.createElement('button');
                button.textContent = getUnitLabel(unit);
                button.onclick = () => window.handleUnitChange(unit);
                button.className = `
                    flex-shrink-0 min-w-[18%] p-3 text-sm sm:text-base font-semibold rounded-lg transition duration-200 shadow-md 
                    ${isActive 
                        ? 'bg-blue-600 text-white shadow-blue-400/50 hover:bg-blue-700' 
                        : 'bg-white text-blue-600 border border-blue-600 hover:bg-blue-50'
                    }
                `;
                container.appendChild(button);
            });
        };

        /**
         * タイムラインデータを再計算し、チャートを再描画する
         */
        const recalculateAndRender = () => {
            if (rawLogData.length > 0 && selectedDate) {
                timelineData = calculateTimeline(rawLogData, selectedDate);
                console.log(`[Recalculate] Timeline for ${selectedDate} updated. Entries: ${timelineData.length}`);
            } else if (selectedDate) {
                timelineData = [];
                console.log(`[Recalculate] No raw data found for ${selectedDate}.`);
            }
            renderApp(); // UI全体を更新（主にタイトルとメッセージ）
            drawChart(); // チャートを再描画
        };


        // =========================================================================
        // Firebase初期化とデータリスナー
        // =========================================================================

        /**
         * Firebaseを初期化し、認証を行う
         */
        const initializeFirebase = async () => {
            if (Object.keys(firebaseConfig).length === 0) {
                console.warn("Firebase config is missing. Using mock user.");
                userId = 'mock_user';
                isLoading = false;
                renderApp();
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser ? auth.currentUser.uid : crypto.randomUUID();
                setupFirestoreListener();
            } catch (e) {
                console.error("Firebase initialization or auth failed:", e);
                error = "Firebaseの初期化または認証に失敗しました。";
                isLoading = false;
                renderApp();
            }
        };

        /**
         * Firestoreのログデータリスナーを設定する
         */
        const setupFirestoreListener = () => {
            if (!db) return;

            // 既存のリスナーがあれば解除
            if (logUnsubscribe) {
                logUnsubscribe();
            }
            
            // /artifacts/{appId}/public/data/log を購読
            const logCollectionRef = collection(db, `artifacts/${appId}/public/data/log`);
            const logQuery = logCollectionRef; 
            console.log(`[Firestore] Subscribing to: log collection.`);

            logUnsubscribe = onSnapshot(logQuery, (snapshot) => {
                const logs = [];
                const uniqueDays = new Set();
                let latestDate = null;
                let foundSelectedDate = false;

                snapshot.forEach(doc => {
                    const log = doc.data();
                    if (log.timestamp && log.event_day) {
                        logs.push(log);
                        uniqueDays.add(log.event_day);

                        if (log.event_day === selectedDate) {
                            foundSelectedDate = true;
                        }

                        // 最新日付を特定
                        try {
                            const logDate = log.timestamp.toDate().getTime();
                            if (latestDate === null || logDate > latestDate.time) {
                                latestDate = { day: log.event_day, time: logDate };
                            }
                        } catch(e) {
                            console.warn("Timestamp conversion error for log:", log, e);
                        }
                    }
                });
                
                rawLogData = logs;
                
                // 日付リストを降順にソートして設定
                datesList = Array.from(uniqueDays).sort((a, b) => b.localeCompare(a));

                // ログが全くない場合、または初期表示日が存在しない場合は最新の日付に設定
                if (datesList.length > 0) {
                    if (!foundSelectedDate && latestDate) {
                        selectedDate = latestDate.day;
                    } else if (!selectedDate || !datesList.includes(selectedDate)) {
                        selectedDate = datesList[0];
                    }
                }

                // ローディングを終了
                isLoading = false;

                // データが更新されたので再計算とレンダリング
                recalculateAndRender();

                console.log(`[Firestore] Log data received. Total entries: ${logs.length}, Unique days: ${datesList.length}`);
            }, (err) => {
                console.error("Firestore listen error (log):", err);
                error = "ログデータの読み込み中にエラーが発生しました。";
                isLoading = false;
                renderApp();
            });
        };

        // =========================================================================
        // アプリケーションのエントリポイント
        // =========================================================================

        window.onload = () => {
            // 初期ローディング表示
            renderApp(); 
            initializeFirebase();

            // 60秒ごとの自動更新を設定
            setInterval(() => {
                // 最後の更新時刻を更新
                const header = document.querySelector('header p');
                if (header) {
                    header.textContent = `最終更新: ${new Date().toLocaleTimeString('ja-JP', { hour12: false })}`;
                }
                drawChart();
            }, 60000);
        };

        // ウィンドウのリサイズ時にチャートを再描画してレスポンシブに対応
        window.addEventListener('resize', () => {
            if (chartInstance) {
                // Chart.jsはresponsive: trueなので、再描画は不要ですが、
                // データの再集計や特別な処理が必要な場合は drawChart() を呼び出します。
                // ここでは不要なため、何もしません。
            }
        });

    </script>
</body>
</html>
